\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}

\begin{document}
\input{definitions.tex}


%%%
%%% ACM SIGPLAN class cruft
%%%

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CoqPL '17}{2017, Paris, France}
\copyrightyear{2017}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

%\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{Predicate Monads}   % 'preprint' option specified.


%%%
%%% Title and Author Info
%%%

%\title{Predicate Monads: A Verification Tool for Monadic Programs}

\title{Predicate Monads:}
\subtitle{A Framework for Proving Generic Properties of Monadic Programs via Rewriting}

\authorinfo{Edwin Westbrook}
           {Galois Inc.}
           {westbrook@galois.com}
\authorinfo{Gregory Malecha}
           {UCSD}
           {gmalecha@gmail.com}

\maketitle

% \begin{abstract}
% This is the text of the abstract.
% \end{abstract}


% \category{CR-number}{subcategory}{third-level}

% % general terms are not compulsory anymore,
% % you may leave them out
% \terms
% term1, term2

% \keywords
% keyword1, keyword2


%%%
%%% Section: Introduction
%%%

\section{Introduction}

% \begin{itemize}
% \item Monads are a great way to structure programs
% \item Monad laws are great for proving equalities, but not arbitrary properties
% \item Set monad construction, with its operations
% \item Generalizing that to pairs of a monad and predicate monad for that monad
% \item Example: Hoare logic
% \end{itemize}

Monads are a simple, elegant, and powerful way to specify effectful programs.
They provide a compositional framework for building program specifications that
supports a wide variety of different sorts of effects, including mutable state,
continuations, errors and exceptions, non-determinism, and many more
\cite{moggi91}.  These effects are defined in a given monad $M$ by exposing a
set of \emph{monadic operations} to implement these effects in $M$. For
instance, if $M$ supports mutable state it often exposes it through the following type signature:
\[
\begin{array}{lcl}
  \returnM & :: & \forall A. A \to M\;A \\
  (\bind) & :: & \forall A. \forall B. M\;A \to (A\to M\;B) \to M\;B \\
  \getM & :: & M\;S \\
  \putM & :: & S \to M\;\unit
\end{array}
\]
The first two of these, $\returnM$ and $\bind$, are the usual monad operations,
for building pure computations and for sequencing two computations together,
while $\getM$ and $\putM$ define operations for reading and writing,
respectively, the current value of the mutable state of type $S$. Note that
we also use the standard abbreviation
\[
m_1 \bindU m_2 = m_1 \bind \lamabs{x:\unit}{m_2}
\]
to sequecne a computation $m_1$ followed by a computation $m_2$ that does not
inspect the return value of $m_1$.


Each monad also comes with a set of reasoning principles, called generally the
\emph{monad laws}, for reasoning about programs written in that monad. These
monad laws take the form of a set of equalities on programs. For instance, in
addition to the standard monad laws for $\returnM$ and $\bind$, a monad that
supports mutable state will generally satisfy the following \emph{state monad
  laws}, stating that $\getM$ and $\putM$ behave as expected:
\[
\begin{array}{lcl}
  \putM\;s \bindU \putM\;s' & = & \putM\;s'\\
  \putM\;s \bind \getM & = & \putM\;s \bindU \returnM\;s \\
  \getM\bind\putM & = & \returnM\;\Tt \\
  \getM\bind \lamabsnot{s}{\getM\bind f\;s} & = & \getM\bind\lamabsnot{s}{f\;s\;s}
\end{array}
\]
A monad that supports multiple effects will additionally include monad laws for
how those effects interact; e.g., a monad with mutable state and errors might
include the law
\[
\putM\;s \bindU \fail = \fail
\]
to indicate that a failure eradicates all mutable state modifications.  A
similar monad with these effects, however, might not satisfy this law, if, for
instance, failures can be recovered from.


Monad laws are a powerful tool that can be used to prove a wide variety of
properties of effectful programs, by using them as rewrite rules. For instance,
Gibbons and Hinze use this approach to verify that a number of effectful
programs have the same behavior as their corresponding functional specifications
\cite{gibbons11}.
%
The key difficulty comes when we want to prove properties other than equalities.
Monad laws cannot, for instance, prove that a function satisfies a given pre-
and post-condition, because this is not a property that can be defined in terms
of equality. Although there are approaches specifically for proving pre- and
post-conditions, such as the Hoare monad \cite{nanevski08} and the Dijkstra
monad \cite{swamy13}, it is not clear that these approaches generalize to
effects other than mutable state, or to combinations of effects.
% FIXME HERE: make this stronger
It is also not clear how to derive the Hoare monad or the Dijkstra monad
structure for an arbitrary monad that does support mutable state.


In this talk, we will present ongoing work on a general framework, called
\emph{predicate monads}, for proving properties of effectful programs that
overcomes these difficulties. The goal of this approach is to leverage the power
and elegance of the monad laws, but apply them not to monadic programs
themselves but to predicates over monadic computations.  More technically, in
our approach, each monad $M$ is associated with a so-called predicate monad $P_M$
which is, intuitively, a monad of predicates on computations in $M$.
If we view $M$ as a domain-specific semantics, then $P_M$ is a
\emph{domain-specific logic}.
% FIXME: make this point better
The predicate monad $P_M$ supports predicates over all of the monadic operations
of $M$, allowing it to reason about arbitrary effects. This reasoning comes in
the form of \emph{predicate monad laws}, which allow predicates to be proved
using rewriting. Additionally, if $M$ is defined using monad transformers, a
powerful and compositional way to build monads \cite{liang95}, then $P_M$ can be
built using the same monad transformers. This allows us to derive predicate
monads for a wide variety of monads and effects in a straightforward manner.

\section{$P_{\mathsf{Identity}} = \mathsf{Set}$}
To make the ideas above precise, we describe the predicate monad for the identity monad.


\begin{itemize}
\item Describe the $\mathsf{SetM}$ monad as a predicate monad for
  $\mathsf{Identity}$
\item Show how to define a pre-condition / post-condition predicate, and
  how to prove it using rewriting
\end{itemize}


\bibliographystyle{abbrvnat}
\bibliography{bib}

\end{document}
